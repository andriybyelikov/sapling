#! /bin/sh

lexer=$(./sapling-backup ../spec/meta -fprint-lexer-automaton 2> /dev/null)
terminals=$(./sapling-backup ../spec/meta -fprint-terminals 2> /dev/null)

echo "#include <stdio.h>"
echo "#include <libsapling/cc/terminal.h>"
echo "#include \"lexer_action.h\""
echo "#include \"autogen_terminals.h\""
echo ""
echo "static"
echo "int next_state(int current_state, char c)"
echo "{"
echo "    switch (current_state) {"
((parbal = 0))
for i in $(seq 1 ${#lexer}); do
    if [[ "${lexer:i-1:1}" == "(" ]]; then
        if (( parbal == 0 )); then
            savpos=$i
        fi
        ((parbal += 1))
    elif [[ "${lexer:i-1:1}" == ")" ]]; then
        ((parbal -= 1))
        if (( parbal == 0 )); then
            sta=${lexer:savpos-1:i-savpos+1}
            id=$(echo "$sta" | sed 's/(\(0x[[:alnum:]]\+\), {.*/\1/')
            echo "    case 0x${id:6:8}:"
            echo "        switch (c) {"
            edges=$(echo "$sta" | sed 's/.*{\(.*\)}.*$/\1/')
            ((parbal_edges = 0))
            for j in $(seq 1 ${#edges}); do
                if [[ "${edges:j-1:1}" == "(" && (( j > 1 )) && "${edges:j-2:1}" != "'" ]]; then
                    if (( parbal_edges == 0 )); then
                        savpos_edges=$j
                    fi
                    ((parbal_edges += 1))
                elif [[ "${edges:j-1:1}" == ")" && "${edges:j:1}" != "'" ]]; then
                    ((parbal_edges -= 1))
                    if (( parbal_edges == 0 )); then
                        edge=${edges:savpos_edges-1:j-savpos_edges+1}
                        attr=$(echo "$edge" | sed "s/.*\('.*'\).*$/\1/")
                        sta2=$(echo "$edge" | sed 's/.*\(0x[[:alnum:]]\+\).*$/\1/')
                        echo "        case $attr:"
                        echo "            return 0x${sta2:6:8};"
                    fi
                fi
            done
            anything_edge=$(echo "$sta" | sed 's/.*}, \(.*\), ., .*$/\1/')
            echo "        default:"
            if [[ "$anything_edge" != "(nil)" ]]; then
                echo "            return 0x${anything_edge:6:8};"
            else
                echo "            return -1;"
            fi
            echo "        }"
            echo "        break;"
        fi
    fi
done
echo "        default:"
echo "            return -1;"
echo "    }"
echo "}"
echo ""
echo "static"
echo "int is_accepting_state(int s)"
echo "{"
echo "    switch (s) {"
((parbal = 0))
for i in $(seq 1 ${#lexer}); do
    if [[ "${lexer:i-1:1}" == "(" ]]; then
        if (( parbal == 0 )); then
            savpos=$i
        fi
        ((parbal += 1))
    elif [[ "${lexer:i-1:1}" == ")" ]]; then
        ((parbal -= 1))
        if (( parbal == 0 )); then
            sta=${lexer:savpos-1:i-savpos+1}
            id=$(echo "$sta" | sed 's/(\(0x[[:alnum:]]\+\), {.*/\1/')
            acc=$(echo "$sta" | sed 's/.*}, .*, \(.\), .*$/\1/')
            echo "    case 0x${id:6:8}:"
            echo "        return $acc;"
        fi
    fi
done
echo "    }"
echo "}"
echo ""
echo "static"
echo "int get_class(int state)"
echo "{"
echo "    switch (state) {"
((parbal = 0))
for i in $(seq 1 ${#lexer}); do
    if [[ "${lexer:i-1:1}" == "(" ]]; then
        if (( parbal == 0 )); then
            savpos=$i
        fi
        ((parbal += 1))
    elif [[ "${lexer:i-1:1}" == ")" ]]; then
        ((parbal -= 1))
        if (( parbal == 0 )); then
            sta=${lexer:savpos-1:i-savpos+1}
            id=$(echo "$sta" | sed 's/(\(0x[[:alnum:]]\+\), {.*/\1/')
            class=$(echo "$sta" | sed 's/.*}, .*, ., \(.*\))$/\1/')
            if [[ "$class" != "(nil)" ]]; then
                echo "    case 0x${id:6:8}:"
                echo "        return $class;"
            fi
        fi
    fi
done
echo "    }"
echo "}"
echo ""
echo "static"
echo "terminal_t build_terminal(char *buf, int bufc, int id)"
echo "{"
echo "    buf[bufc] = 0;"
echo "    return new_terminal(id, buf);"
echo "}"
echo ""
echo "terminal_t fetch_terminal(FILE *input_file, void *user_ptr)"
echo "{"
echo "    char c;              // single character buffer"
initial_state=$(echo "$lexer" | sed 's/{ (\(0x[[:alnum:]]\+\).*$/\1/')
echo "    int s = 0x${initial_state:6:8};  // state"
echo "    char buf[4096];      // lexeme buffer"
echo "    int bufc = 0;        // lexeme buffer cursor"
echo "    terminal_t terminal; // terminal buffer"
echo "    int class = -1;"
echo "    int overread = 0;"
echo "    int cont = 1;"
echo ""
echo "    while (cont) {"
echo "        c = getc(input_file);"
echo "        if (c == EOF) {"
echo "            terminal = build_terminal(buf, bufc, t_eof);"
echo "            lexer_action(terminal, user_ptr);"
echo "            return terminal;"
echo "        } else {"
echo "            if (is_accepting_state(s)) {"
echo "                class = get_class(s);"
echo "                overread = 0;"
echo "            }"
echo "            s = next_state(s, c);"
echo "            buf[bufc++] = c;"
echo "            overread++;"
echo "            if (s == -1) {"
echo "                for (int i = 0; i < overread; i++) {"
echo "                    ungetc(c, input_file);"
echo "                    bufc--;"
echo "                }"
echo "                overread = 0;"
echo "                s = 0x${initial_state:6:8};"
echo -n "                if (1"
for t in $terminals; do
    if [[ "${t:0:10}" == "t_gobble__" ]]; then
        echo -n " && class != $t"
    fi
done
echo ")"
echo "                    cont = 0;"
echo "                else"
echo "                    bufc = 0;"
echo "            }"
echo "        }"
echo "    }"
echo "    if (class == -1)"
echo "        return NULL;"
echo "    terminal = build_terminal(buf, bufc, class);"
echo "    lexer_action(terminal, user_ptr);"
echo "    return terminal;"
echo "}"
